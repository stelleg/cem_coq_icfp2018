\section{Conclusion} \label{sec:conclusion}

We have shown how to build a verified compiler that verifies time and space
requirements in addition to the usual correctness properties. We have used this
technique to build a verified compiler of call-by-need, proving that the
memoization of results is implemented correctly. This is the first
machine-checked proof that an optimization is \emph{preserved through
compilation} that we are aware of. 

Typed functional language programmers have long leaned on the important property
that their programs "can't go wrong". Historically this property has always
included an important asterisk: "unless it runs out of time or memory". Without
tools to reason formally about time and memory usage this asterisk is impossible
to confront. We have shown how one can reason formally about properties like
stack size and heap size, in a way that is preserved to machine code, enabling
programmers to finally manage this wart.


